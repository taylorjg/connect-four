{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./logic/index.js","webpack:///./minimax/index.js","webpack:///./node_modules/promise-worker/register.js","webpack:///./web-app/web-worker.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA,OAAO,uBAAuB,GAAG,mBAAO,CAAC,sCAAY;;AAErD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,wBAAwB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC/KA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS,OAAO;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/FY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,KAAK;AACL,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;AC7EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2D;AAC3B;AACS;;AAEzC,gBAAgB,4CAAK;;AAErB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA,kBAAkB,4CAAK;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,6DAAY;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,aAAa;AACpD;AACA;;AAEA,8DAAqB;AACrB,uCAAuC,wBAAwB;AAC/D;AACA,sCAAsC,uBAAuB;AAC7D;AACA,CAAC","file":"0.bundle.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./web-app/web-worker.js\");\n","const { PieceBase, BoardBase } = require('../minimax')\n\nconst range = n => Array.from(Array(n).keys())\n\nclass Piece extends PieceBase {\n\n  constructor(piece) {\n    super()\n    this.piece = piece\n  }\n\n  get opposite() {\n    switch (this.piece) {\n      case \"R\": return Y\n      case \"Y\": return R\n      case \"-\": return E\n    }\n    throw new Error(`Unknown piece, \"${this.piece}\".`)\n  }\n}\n\nconst R = new Piece(\"R\")\nconst Y = new Piece(\"Y\")\nconst E = new Piece(\"-\")\n\nconst generateSegments = (numRows, numColumns, segmentLength) => {\n  const segments = []\n  // vertical segments\n  for (const c of range(numColumns)) {\n    for (const r of range(numRows - segmentLength + 1)) {\n      const segment = []\n      for (const t of range(segmentLength)) {\n        segment.push([r + t, c])\n      }\n      segments.push(segment)\n    }\n  }\n  // horizontal segments\n  for (const c of range(numColumns - segmentLength + 1)) {\n    for (const r of range(numRows)) {\n      const segment = []\n      for (const t of range(segmentLength)) {\n        segment.push([r, c + t])\n      }\n      segments.push(segment)\n    }\n  }\n  // diagonal segments /\n  for (const c of range(numColumns - segmentLength + 1)) {\n    for (const r of range(numRows - segmentLength + 1)) {\n      const segment = []\n      for (const t of range(segmentLength)) {\n        segment.push([r + t, c + t])\n      }\n      segments.push(segment)\n    }\n  }\n  // diagonal segments \\\n  for (const c of range(numColumns - segmentLength + 1)) {\n    for (const r of range(numRows - segmentLength + 1)) {\n      const segment = []\n      for (const t of range(segmentLength)) {\n        segment.push([r + segmentLength - 1 - t, c + t])\n      }\n      segments.push(segment)\n    }\n  }\n  return segments\n}\n\nconst NUM_ROWS = 6\nconst NUM_COLUMNS = 7\nconst SEGMENT_LENGTH = 4\nconst SEGMENTS = generateSegments(NUM_ROWS, NUM_COLUMNS, SEGMENT_LENGTH)\n\nclass Column {\n\n  constructor(container) {\n    this._container = container || []\n  }\n\n  get full() {\n    return this._container.length === NUM_ROWS\n  }\n\n  rowAt(index) {\n    if (index >= this._container.length) return E\n    return this._container[index]\n  }\n\n  push(piece) {\n    if (this.full) {\n      throw new Error('Trying to push piece to full column.')\n    }\n    this._container.push(piece)\n  }\n\n  copy() {\n    return new Column(this._container.slice())\n  }\n}\n\nclass Board extends BoardBase {\n\n  constructor(columns, turn) {\n    super()\n    this._columns = columns || range(NUM_COLUMNS).map(() => new Column())\n    this._turn = turn || R\n  }\n\n  get turn() {\n    return this._turn\n  }\n\n  get isWin() {\n    for (const segment of SEGMENTS) {\n      const { redCount, yellowCount } = this._countSegment(segment)\n      if (redCount === SEGMENT_LENGTH || yellowCount === SEGMENT_LENGTH) {\n        return segment\n      }\n    }\n    return false\n  }\n\n  legalMoves() {\n    return range(NUM_COLUMNS).filter(c => !this._columns[c].full)\n  }\n\n  makeMove(c) {\n    const newColumns = this._columns.map(p => p.copy())\n    newColumns[c].push(this.turn)\n    const newTurn = this.turn.opposite\n    return new Board(newColumns, newTurn)\n  }\n\n  evaluate(player) {\n    return SEGMENTS.reduce(\n      (acc, segment) => acc + this._evaluateSegment(segment, player),\n      0)\n  }\n\n  _countSegment(segment) {\n    const countPieces = piece => segment\n      .filter(([row, col]) => this._columns[col].rowAt(row) === piece)\n      .length\n    const redCount = countPieces(R)\n    const yellowCount = countPieces(Y)\n    return { redCount, yellowCount }\n  }\n\n  _countToScore(count) {\n    switch (count) {\n      case 2: return 1\n      case 3: return 100\n      case 4: return 1000000\n      default: return 0\n    }\n  }\n\n  _evaluateSegment(segment, colour) {\n    const { redCount, yellowCount } = this._countSegment(segment)\n    if (redCount && yellowCount) return 0\n    const bestScore = this._countToScore(Math.max(redCount, yellowCount))\n    const bestColour = redCount > yellowCount ? R : Y\n    return colour === bestColour ? bestScore : -bestScore\n  }\n\n  get grid() {\n    return range(NUM_ROWS).map(row =>\n      range(NUM_COLUMNS).map(col => this._columns[col].rowAt(row).piece).join(''))\n  }\n}\n\nmodule.exports = {\n  Board\n}\n","class PieceBase {\n  get opposite() {\n    throw new Error('[PieceBase#opposite] abstract property!')\n  }\n}\n\nclass BoardBase {\n\n  get turn() {\n    throw new Error('[BoardBase#turn] abstract property!')\n  }\n\n  get isWin() {\n    throw new Error('[BoardBase#isWin] abstract property!')\n  }\n\n  get isDraw() {\n    return !this.isWin && !this.legalMoves().length\n  }\n\n  legalMoves() {\n    throw new Error('[BoardBase#legalMoves] abstract method!')\n  }\n\n  makeMove() {\n    throw new Error('[BoardBase#makeMove] abstract method!')\n  }\n\n  evaluate() {\n    throw new Error('[BoardBase#evaluate] abstract method!')\n  }\n}\n\n// const minimax = (board, maximising, originalPlayer, maxDepth) => {\n//   if (board.isWin || board.isDraw || maxDepth === 0) {\n//     return board.evaluate(originalPlayer)\n//   }\n//   if (maximising) {\n//     const op = (acc, move) => {\n//       const score = minimax(board.makeMove(move), false, originalPlayer, maxDepth - 1)\n//       return Math.max(acc, score)\n//     }\n//     return board.legalMoves().reduce(op, Number.MIN_SAFE_INTEGER)\n//   } else {\n//     const op = (acc, move) => {\n//       const score = minimax(board.makeMove(move), true, originalPlayer, maxDepth - 1)\n//       return Math.min(acc, score)\n//     }\n//     return board.legalMoves().reduce(op, Number.MAX_SAFE_INTEGER)\n//   }\n// }\n\nconst alphabeta = (\n  board,\n  maximising,\n  originalPlayer,\n  maxDepth,\n  alpha = Number.MIN_SAFE_INTEGER,\n  beta = Number.MAX_SAFE_INTEGER) => {\n  if (board.isWin || board.isDraw || maxDepth === 0) {\n    return board.evaluate(originalPlayer)\n  }\n  if (maximising) {\n    for (const move of board.legalMoves()) {\n      const score = alphabeta(board.makeMove(move), false, originalPlayer, maxDepth - 1, alpha, beta)\n      alpha = Math.max(score, alpha)\n      if (beta <= alpha) break\n    }\n    return alpha\n  } else {\n    for (const move of board.legalMoves()) {\n      const score = alphabeta(board.makeMove(move), true, originalPlayer, maxDepth - 1, alpha, beta)\n      beta = Math.min(score, beta)\n      if (beta <= alpha) break\n    }\n    return beta\n  }\n}\n\nconst findBestMove = (board, maxDepth) => {\n  const seed = { score: Number.MIN_SAFE_INTEGER }\n  const op = (acc, move) => {\n    const score = alphabeta(board.makeMove(move), false, board.turn, maxDepth)\n    return score > acc.score\n      ? { score, move }\n      : acc\n  }\n  const { move } = board.legalMoves().reduce(op, seed)\n  return move\n}\n\nmodule.exports = {\n  PieceBase,\n  BoardBase,\n  findBestMove\n}\n","'use strict'\n\nfunction isPromise (obj) {\n  // via https://unpkg.com/is-promise@2.1.0/index.js\n  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function'\n}\n\nfunction registerPromiseWorker (callback) {\n  function postOutgoingMessage (e, messageId, error, result) {\n    function postMessage (msg) {\n      /* istanbul ignore if */\n      if (typeof self.postMessage !== 'function') { // service worker\n        e.ports[0].postMessage(msg)\n      } else { // web worker\n        self.postMessage(msg)\n      }\n    }\n    if (error) {\n      /* istanbul ignore else */\n      if (typeof console !== 'undefined' && 'error' in console) {\n        // This is to make errors easier to debug. I think it's important\n        // enough to just leave here without giving the user an option\n        // to silence it.\n        console.error('Worker caught an error:', error)\n      }\n      postMessage([messageId, {\n        message: error.message\n      }])\n    } else {\n      postMessage([messageId, null, result])\n    }\n  }\n\n  function tryCatchFunc (callback, message) {\n    try {\n      return { res: callback(message) }\n    } catch (e) {\n      return { err: e }\n    }\n  }\n\n  function handleIncomingMessage (e, callback, messageId, message) {\n    var result = tryCatchFunc(callback, message)\n\n    if (result.err) {\n      postOutgoingMessage(e, messageId, result.err)\n    } else if (!isPromise(result.res)) {\n      postOutgoingMessage(e, messageId, null, result.res)\n    } else {\n      result.res.then(function (finalResult) {\n        postOutgoingMessage(e, messageId, null, finalResult)\n      }, function (finalError) {\n        postOutgoingMessage(e, messageId, finalError)\n      })\n    }\n  }\n\n  function onIncomingMessage (e) {\n    var payload = e.data\n    if (!Array.isArray(payload) || payload.length !== 2) {\n      // message doens't match communication format; ignore\n      return\n    }\n    var messageId = payload[0]\n    var message = payload[1]\n\n    if (typeof callback !== 'function') {\n      postOutgoingMessage(e, messageId, new Error(\n        'Please pass a function into register().'))\n    } else {\n      handleIncomingMessage(e, callback, messageId, message)\n    }\n  }\n\n  self.addEventListener('message', onIncomingMessage)\n}\n\nmodule.exports = registerPromiseWorker\n","import registerPromiseWorker from 'promise-worker/register'\nimport { Board } from '../logic'\nimport { findBestMove } from '../minimax'\n\nlet board = new Board()\n\nconst getBoardState = () => ({\n  grid: board.grid,\n  isWin: board.isWin,\n  isDraw: board.isDraw,\n  legalMoves: board.legalMoves()\n})\n\nconst processMessage = message => {\n  switch (message.type) {\n\n    case 'resetBoardState':\n      board = new Board()\n      return getBoardState()\n\n    case 'getBoardState':\n      return getBoardState()\n\n    case 'makeHumanMove':\n      {\n        board = board.makeMove(message.move)\n        return {\n          lastMove: message.move,\n          ...getBoardState()\n        }\n      }\n\n    case 'makeComputerMove':\n      {\n        const move = findBestMove(board, message.maxDepth)\n        board = board.makeMove(move)\n        return {\n          lastMove: move,\n          ...getBoardState()\n        }\n      }\n\n    default:\n      return `Unknown message.type, \"${message.type}\".`\n  }\n}\n\nregisterPromiseWorker(message => {\n  console.log(`[web-worker] message: ${JSON.stringify(message)}`)\n  const result = processMessage(message)\n  console.log(`[web-worker] result: ${JSON.stringify(result)}`)\n  return result\n})\n"],"sourceRoot":""}